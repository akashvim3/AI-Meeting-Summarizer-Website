import { type NextRequest, NextResponse } from "next/server"
import { jsPDF } from "jspdf"

export async function POST(request: NextRequest) {
  try {
    const { summary, format, exportFormat, meetingTitle } = await request.json()

    if (!summary || !exportFormat) {
      return NextResponse.json({ error: "Missing required parameters" }, { status: 400 })
    }

    const title = meetingTitle || `Meeting Summary - ${new Date().toLocaleDateString()}`

    let content: string
    let filename: string
    let mimeType: string

    switch (exportFormat) {
      case "markdown":
        content = generateMarkdown(summary, title, format)
        filename = `${title.replace(/[^a-z0-9]/gi, "_").toLowerCase()}.md`
        mimeType = "text/markdown"
        break

      case "pdf":
        const pdfBuffer = generatePDF(summary, title, format)
        filename = `${title.replace(/[^a-z0-9]/gi, "_").toLowerCase()}.pdf`

        return new NextResponse(pdfBuffer, {
          headers: {
            "Content-Type": "application/pdf",
            "Content-Disposition": `attachment; filename="${filename}"`,
          },
        })

      case "docx":
        content = generateWordDocument(summary, title, format)
        filename = `${title.replace(/[^a-z0-9]/gi, "_").toLowerCase()}.docx`
        mimeType = "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
        break

      case "txt":
        content = generatePlainText(summary, title, format)
        filename = `${title.replace(/[^a-z0-9]/gi, "_").toLowerCase()}.txt`
        mimeType = "text/plain"
        break

      default:
        return NextResponse.json({ error: "Unsupported export format" }, { status: 400 })
    }

    if (exportFormat !== "pdf") {
      return new NextResponse(content, {
        headers: {
          "Content-Type": mimeType,
          "Content-Disposition": `attachment; filename="${filename}"`,
        },
      })
    }
  } catch (error) {
    console.error("Export error:", error)
    return NextResponse.json({ error: "Failed to generate export" }, { status: 500 })
  }
}

function generateMarkdown(summary: any, title: string, format: string): string {
  const date = new Date().toLocaleDateString()

  let markdown = `# ${title}\n\n`
  markdown += `**Date:** ${date}  \n`
  markdown += `**Format:** ${format.charAt(0).toUpperCase() + format.slice(1)}  \n\n`
  markdown += `---\n\n`

  if (summary.overview) {
    markdown += `## Meeting Overview\n\n${summary.overview}\n\n`
  }

  if (summary.keyPoints && summary.keyPoints.length > 0) {
    markdown += `## Key Discussion Points\n\n`
    summary.keyPoints.forEach((point: string) => {
      markdown += `- ${point}\n`
    })
    markdown += `\n`
  }

  if (summary.decisions && summary.decisions.length > 0) {
    markdown += `## Decisions Made\n\n`
    summary.decisions.forEach((decision: string) => {
      markdown += `- ${decision}\n`
    })
    markdown += `\n`
  }

  if (summary.actionItems && summary.actionItems.length > 0) {
    markdown += `## Action Items\n\n`
    summary.actionItems.forEach((item: string) => {
      markdown += `- [ ] ${item}\n`
    })
    markdown += `\n`
  }

  if (summary.questions && summary.questions.length > 0) {
    markdown += `## Questions Raised\n\n`
    summary.questions.forEach((question: string) => {
      markdown += `- ${question}\n`
    })
    markdown += `\n`
  }

  if (summary.quotes && summary.quotes.length > 0) {
    markdown += `## Important Quotes\n\n`
    summary.quotes.forEach((quote: string) => {
      markdown += `> "${quote}"\n\n`
    })
  }

  markdown += `---\n\n*Generated by AI Meeting Notes Summarizer on ${date}*`

  return markdown
}

function generatePDF(summary: any, title: string, format: string): Buffer {
  const doc = new jsPDF()
  const pageWidth = doc.internal.pageSize.width
  const margin = 20
  const lineHeight = 7
  let yPosition = margin

  // Helper function to add text with word wrapping
  const addWrappedText = (text: string, x: number, y: number, maxWidth: number, fontSize = 12): number => {
    doc.setFontSize(fontSize)
    const lines = doc.splitTextToSize(text, maxWidth)
    doc.text(lines, x, y)
    return y + lines.length * lineHeight
  }

  // Helper function to check if we need a new page
  const checkNewPage = (requiredSpace: number): number => {
    if (yPosition + requiredSpace > doc.internal.pageSize.height - margin) {
      doc.addPage()
      return margin
    }
    return yPosition
  }

  // Title
  doc.setFontSize(20)
  doc.setFont(undefined, "bold")
  yPosition = addWrappedText(title, margin, yPosition, pageWidth - 2 * margin, 20)
  yPosition += 10

  // Metadata
  doc.setFontSize(10)
  doc.setFont(undefined, "normal")
  doc.text(`Date: ${new Date().toLocaleDateString()}`, margin, yPosition)
  yPosition += lineHeight
  doc.text(`Format: ${format.charAt(0).toUpperCase() + format.slice(1)}`, margin, yPosition)
  yPosition += 15

  // Meeting Overview
  if (summary.overview) {
    yPosition = checkNewPage(30)
    doc.setFontSize(16)
    doc.setFont(undefined, "bold")
    doc.text("Meeting Overview", margin, yPosition)
    yPosition += 10

    doc.setFont(undefined, "normal")
    yPosition = addWrappedText(summary.overview, margin, yPosition, pageWidth - 2 * margin, 12)
    yPosition += 15
  }

  // Key Discussion Points
  if (summary.keyPoints && summary.keyPoints.length > 0) {
    yPosition = checkNewPage(30)
    doc.setFontSize(16)
    doc.setFont(undefined, "bold")
    doc.text("Key Discussion Points", margin, yPosition)
    yPosition += 10

    doc.setFont(undefined, "normal")
    summary.keyPoints.forEach((point: string) => {
      yPosition = checkNewPage(15)
      yPosition = addWrappedText(`• ${point}`, margin, yPosition, pageWidth - 2 * margin, 12)
      yPosition += 5
    })
    yPosition += 10
  }

  // Decisions Made
  if (summary.decisions && summary.decisions.length > 0) {
    yPosition = checkNewPage(30)
    doc.setFontSize(16)
    doc.setFont(undefined, "bold")
    doc.text("Decisions Made", margin, yPosition)
    yPosition += 10

    doc.setFont(undefined, "normal")
    summary.decisions.forEach((decision: string) => {
      yPosition = checkNewPage(15)
      yPosition = addWrappedText(`• ${decision}`, margin, yPosition, pageWidth - 2 * margin, 12)
      yPosition += 5
    })
    yPosition += 10
  }

  // Action Items
  if (summary.actionItems && summary.actionItems.length > 0) {
    yPosition = checkNewPage(30)
    doc.setFontSize(16)
    doc.setFont(undefined, "bold")
    doc.text("Action Items", margin, yPosition)
    yPosition += 10

    doc.setFont(undefined, "normal")
    summary.actionItems.forEach((item: string) => {
      yPosition = checkNewPage(15)
      yPosition = addWrappedText(`☐ ${item}`, margin, yPosition, pageWidth - 2 * margin, 12)
      yPosition += 5
    })
    yPosition += 10
  }

  // Questions Raised
  if (summary.questions && summary.questions.length > 0) {
    yPosition = checkNewPage(30)
    doc.setFontSize(16)
    doc.setFont(undefined, "bold")
    doc.text("Questions Raised", margin, yPosition)
    yPosition += 10

    doc.setFont(undefined, "normal")
    summary.questions.forEach((question: string) => {
      yPosition = checkNewPage(15)
      yPosition = addWrappedText(`• ${question}`, margin, yPosition, pageWidth - 2 * margin, 12)
      yPosition += 5
    })
    yPosition += 10
  }

  // Important Quotes
  if (summary.quotes && summary.quotes.length > 0) {
    yPosition = checkNewPage(30)
    doc.setFontSize(16)
    doc.setFont(undefined, "bold")
    doc.text("Important Quotes", margin, yPosition)
    yPosition += 10

    doc.setFont(undefined, "italic")
    summary.quotes.forEach((quote: string) => {
      yPosition = checkNewPage(20)
      yPosition = addWrappedText(`"${quote}"`, margin + 10, yPosition, pageWidth - 2 * margin - 20, 12)
      yPosition += 10
    })
  }

  // Footer
  const pageCount = doc.getNumberOfPages()
  for (let i = 1; i <= pageCount; i++) {
    doc.setPage(i)
    doc.setFontSize(8)
    doc.setFont(undefined, "normal")
    doc.text(
      `Generated by AI Meeting Notes Summarizer - Page ${i} of ${pageCount}`,
      pageWidth / 2,
      doc.internal.pageSize.height - 10,
      { align: "center" },
    )
  }

  return Buffer.from(doc.output("arraybuffer"))
}

function generateWordDocument(summary: any, title: string, format: string): string {
  // For a simple implementation, we'll generate RTF format which can be opened by Word
  let rtf = `{\\rtf1\\ansi\\deff0 {\\fonttbl {\\f0 Times New Roman;}}\\f0\\fs24`

  // Title
  rtf += `\\b\\fs32 ${title}\\b0\\fs24\\par\\par`

  // Metadata
  rtf += `\\b Date:\\b0 ${new Date().toLocaleDateString()}\\par`
  rtf += `\\b Format:\\b0 ${format.charAt(0).toUpperCase() + format.slice(1)}\\par\\par`

  // Meeting Overview
  if (summary.overview) {
    rtf += `\\b\\fs28 Meeting Overview\\b0\\fs24\\par`
    rtf += `${summary.overview}\\par\\par`
  }

  // Key Discussion Points
  if (summary.keyPoints && summary.keyPoints.length > 0) {
    rtf += `\\b\\fs28 Key Discussion Points\\b0\\fs24\\par`
    summary.keyPoints.forEach((point: string) => {
      rtf += `\\bullet ${point}\\par`
    })
    rtf += `\\par`
  }

  // Decisions Made
  if (summary.decisions && summary.decisions.length > 0) {
    rtf += `\\b\\fs28 Decisions Made\\b0\\fs24\\par`
    summary.decisions.forEach((decision: string) => {
      rtf += `\\bullet ${decision}\\par`
    })
    rtf += `\\par`
  }

  // Action Items
  if (summary.actionItems && summary.actionItems.length > 0) {
    rtf += `\\b\\fs28 Action Items\\b0\\fs24\\par`
    summary.actionItems.forEach((item: string) => {
      rtf += `\\bullet ${item}\\par`
    })
    rtf += `\\par`
  }

  // Questions Raised
  if (summary.questions && summary.questions.length > 0) {
    rtf += `\\b\\fs28 Questions Raised\\b0\\fs24\\par`
    summary.questions.forEach((question: string) => {
      rtf += `\\bullet ${question}\\par`
    })
    rtf += `\\par`
  }

  // Important Quotes
  if (summary.quotes && summary.quotes.length > 0) {
    rtf += `\\b\\fs28 Important Quotes\\b0\\fs24\\par`
    summary.quotes.forEach((quote: string) => {
      rtf += `\\i "${quote}"\\i0\\par\\par`
    })
  }

  rtf += `\\par\\i Generated by AI Meeting Notes Summarizer on ${new Date().toLocaleDateString()}\\i0}`

  return rtf
}

function generatePlainText(summary: any, title: string, format: string): string {
  const date = new Date().toLocaleDateString()

  let text = `${title}\n`
  text += `${"=".repeat(title.length)}\n\n`
  text += `Date: ${date}\n`
  text += `Format: ${format.charAt(0).toUpperCase() + format.slice(1)}\n\n`
  text += `${"-".repeat(50)}\n\n`

  if (summary.overview) {
    text += `MEETING OVERVIEW\n${"-".repeat(16)}\n${summary.overview}\n\n`
  }

  if (summary.keyPoints && summary.keyPoints.length > 0) {
    text += `KEY DISCUSSION POINTS\n${"-".repeat(21)}\n`
    summary.keyPoints.forEach((point: string, index: number) => {
      text += `${index + 1}. ${point}\n`
    })
    text += `\n`
  }

  if (summary.decisions && summary.decisions.length > 0) {
    text += `DECISIONS MADE\n${"-".repeat(14)}\n`
    summary.decisions.forEach((decision: string, index: number) => {
      text += `${index + 1}. ${decision}\n`
    })
    text += `\n`
  }

  if (summary.actionItems && summary.actionItems.length > 0) {
    text += `ACTION ITEMS\n${"-".repeat(12)}\n`
    summary.actionItems.forEach((item: string, index: number) => {
      text += `[ ] ${index + 1}. ${item}\n`
    })
    text += `\n`
  }

  if (summary.questions && summary.questions.length > 0) {
    text += `QUESTIONS RAISED\n${"-".repeat(16)}\n`
    summary.questions.forEach((question: string, index: number) => {
      text += `${index + 1}. ${question}\n`
    })
    text += `\n`
  }

  if (summary.quotes && summary.quotes.length > 0) {
    text += `IMPORTANT QUOTES\n${"-".repeat(16)}\n`
    summary.quotes.forEach((quote: string, index: number) => {
      text += `${index + 1}. "${quote}"\n\n`
    })
  }

  text += `${"-".repeat(50)}\n`
  text += `Generated by AI Meeting Notes Summarizer on ${date}`

  return text
}
